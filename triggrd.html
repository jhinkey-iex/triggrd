<html>
    <head>
        <title>Triggrd</title>
<script>
const token='pk_ee6a174ecb4e4aaf99ea0da688a9b367';
const log = console;
let party;

const triggerInfo = {
    ballot: {
        /* url can be function or string */
        url: 'https://cloud.iexapis.com/v1/query/DEV/GENERIC_BALLOT_AVERAGES/2022/?last=2',
        period: 10 * 1000,
        /* The state is kept along with the trigger definitions for convenience. */
        state: {
        },
        handleUpdate(ti, data) {
            function diff(data) {
                const mine = +(data[1].candidate === party);
                const other = +!mine;
                log.debug("mine: %d; other: %d", mine, other);
                return data[mine].pct_estimate - data[other].pct_estimate;
            }
            if (data.length > 1 && ti.state.el) {
                const newDiff = diff(data);
                const oldDiff = diff(ti.state.el);
                log.debug('oldDiff: %d, newDiff: %d', oldDiff, newDiff);
                if (newDiff < oldDiff)
                    log.info("kitten me");
                else
                    log.info("don't kitten me");
            }
            if (data.length) {
                log.debug('save data: %s', JSON.stringify(data));
                log.debug('diff would be %f', diff(data));
                ti.state.el = data;
            }
        }
    },
    recession: {
        url: '', // TODO
        period: 10000,
    },
};

function pollTrigger(ti) {
    log.debug("pollTrigger: %s", ti.url);
    const urlSansToken = 'function' === typeof(ti.url) ? ti.url() : ti.url;
    const sep = urlSansToken.includes('?') ? '&' : '?';
    const url = urlSansToken + sep + 'token=' + token;
    log.debug("URL: %s", url);
    fetch(url)
        .then(response => {
            if (response.status === 200)
                return response.json();
            else
                return Promise.reject(`status of ${url} is ${response.status}`);
        })
        .then(ti.handleUpdate.bind(null, ti))
        .catch(e => log.error("polling %s error: %o", url, e));
}

function nextPage(current, next) {
    document.getElementById(current).style.visibility = 'hidden';
    document.getElementById(next).style.visibility = 'visible';
}

function startPollingTrigger(triggerName) {
    log.debug("start polling trigger %s", triggerName);
    const ti = triggerInfo[triggerName];
    pollTrigger(ti);
    setInterval(pollTrigger, ti.period, ti);
}

function actOnTriggers() {
    party = document.forms[0].party.value;
    const triggers = document.forms[0];
    for (const tr of triggers)
        if (tr.checked)
            startPollingTrigger(tr.value);
    nextPage("second", "third");
}
</script>
<style>
div {
    visibility: hidden;
    position: absolute;
    top: 0px;
    left: 0px;
}
</style>
</head>

<body>

<div id=first style='visibility: visible'>
<!-- This is the first page users see when they open the app -->
<h1>First page</h1>

<p>
<a href='' onClick='nextPage("first", "second"); return false;'>Go to second page</a>
</div>

<div id=second>
<!-- This is the second page -->
<h1>Second page</h1>

<h2>Select your triggers:</h2>
<form onSubmit='actOnTriggers(); return false;'>
    <input type=checkbox name=triggers value=ballot>Generic Ballot
        <select name=party>
            <option value=Democrats>Democrat
            <option value=Republicans>Republican
        </select><br>
    <input type=checkbox name=triggers value=recession>Probability of a Recession<br>
    <p>
    <input type=submit value='Register My Triggers'>
</form>
</div>

<div id=third>
<!-- This is where notifications happen (at this point, we are already
     polling. -->
<h1>Notifications</h1>

TODO
</div>

</body>
</html>
<!-- vim:sts=4:et:sw=4: -->
